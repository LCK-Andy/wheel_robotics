Sympy makes it easy to work with **matrices**, **Jacobians**, and **Hessians** symbolically. Here’s a practical overview with examples.  

---

## 🧮 1. Defining and Manipulating Matrices

You can create matrices explicitly or from symbolic variables.

```python
from sympy import Matrix, symbols

x, y, z = symbols('x y z')

# Define a matrix explicitly
A = Matrix([[1, 2], [3, 4]])

# Define a symbolic matrix
B = Matrix([[x, y], [y, z]])

# Basic operations
det_A = A.det()          # Determinant
inv_A = A.inv()          # Inverse
trace_B = B.trace()      # Trace
trans_B = B.T            # Transpose

# Matrix product
prod = A * B

print(det_A, inv_A, trace_B, trans_B, prod)
```

---

## 🧰 2. Jacobian Matrix

The **Jacobian** is the matrix of all first-order partial derivatives of a vector function.

For a vector function **f(x, y)** = [f₁(x, y), f₂(x, y)],  
the Jacobian wrt [x, y] is:

\[
J = \begin{bmatrix}
∂f₁/∂x & ∂f₁/∂y \\
∂f₂/∂x & ∂f₂/∂y
\end{bmatrix}
\]

**Example:**

```python
from sympy import symbols, Matrix

x, y = symbols('x y')

# Define a vector function
f = Matrix([x**2 + y, x*y + y**2])

# Variables
vars = Matrix([x, y])

# Compute Jacobian
J = f.jacobian(vars)
J
```

Expected output:

```
Matrix([
[2*x, 1],
[y, 2*y + x]
])
```

---

## ⚙️ 3. Hessian Matrix

The **Hessian** is a **square** matrix of second-order partial derivatives of a scalar function.

\[
H = \begin{bmatrix}
∂²f/∂x₁² & ∂²f/∂x₁∂x₂ & ... \\
∂²f/∂x₂∂x₁ & ∂²f/∂x₂² & ... \\
... & ... & ...
\end{bmatrix}
\]

**Example:**

```python
from sympy import hessian

x, y = symbols('x y')
f = x**3 + x*y + y**2

H = hessian(f, (x, y))
H
```

Expected result:

```
Matrix([
[6*x, 1],
[1, 2]
])
```

---

## 🧩 4. Numeric Evaluation and Substitution

Once you compute Jacobians or Hessians, you can substitute values or evaluate them numerically.

```python
# Substitute x=1, y=2 into the Hessian
H_val = H.subs({x: 1, y: 2})

# Convert symbolic to numeric
H_numeric = H_val.evalf()

print(H_numeric)
```

---

## 🧠 5. Advanced: Block Matrices, Eigenvalues, etc.

```python
# Block matrix
A = Matrix([[1, 2], [3, 4]])
B = Matrix([[x, y], [y, z]])
M = Matrix.vstack(A, B)

# Eigen decomposition
eigvals = B.eigenvals()
eigvecs = B.eigenvects()

print(eigvals)
```

---

### 📚 Summary

| Concept | Sympy Function | Description |
|----------|----------------|--------------|
| Matrix | `Matrix(...)` | Create and manipulate matrices |
| Jacobian | `f.jacobian(vars)` | Compute Jacobian of vector function |
| Hessian | `hessian(f, vars)` | Compute Hessian of scalar function |
| Substitute values | `.subs({...})` | Plug in numerical or symbolic substitutions |
| Evaluate numerically | `.evalf()` | Get float approximation |

---

Would you like me to show a **visual example** (heatmap or contour plot) of a Hessian or gradient field using Sympy + Matplotlib?